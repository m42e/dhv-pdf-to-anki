# /// script
# dependencies = [
#     "genanki",
# ]
# description = "Anki Deck Generator for Paragliding Questions"
# ///
"""
Anki Deck Generator for Paragliding Questions

This script generates an Anki deck from the questions.json file, including
images when referenced in the "abbildung" field.
"""

import json
import os
import genanki # type: ignore
import hashlib
from pathlib import Path
from typing import Dict, List, Any, Optional, Union

# Define custom note model for paragliding questdef main() -> None:
PARAGLIDING_MODEL = genanki.Model(
    1607392319,  # Unique model ID
    'Paragliding Question Model',
    fields=[
        {'name': 'QuestionID'},
        {'name': 'Section'},
        {'name': 'Subsection'},
        {'name': 'Question'},
        {'name': 'AnswerA'},
        {'name': 'AnswerB'},
        {'name': 'AnswerC'},
        {'name': 'AnswerD'},
        {'name': 'CorrectAnswers'},
        {'name': 'Image'},
    ],
    templates=[
        {
            'name': 'Paragliding Question',
            'qfmt': '''
<div class="question-container">
    <div class="meta-info">
        <div class="section">{{Section}}</div>
        <div class="subsection">{{Subsection}}</div>
    </div>
    
    <div class="question">
        <h3>{{Question}}</h3>
    </div>
    
    <div class="answers" id="answers">
        <!-- Answers will be dynamically generated by JavaScript -->
    </div>

    {{#Image}}
    <div class="image-container">
       {{Image}}
    </div>
    {{/Image}}
    
</div>

<script>
// Store original answers
var originalAnswers = [
    { label: 'A', text: "{{AnswerA}}" },
    { label: 'B', text: "{{AnswerB}}" },
    { label: 'C', text: "{{AnswerC}}" },
    { label: 'D', text: "{{AnswerD}}" }
];

// Generate a seed based on current date for daily shuffling
// This ensures answers are shuffled differently each day but consistently within the same day
var today = new Date();
var dateString = today.getFullYear() + "-" + (today.getMonth() + 1) + "-" + today.getDate();
var questionId = "{{QuestionID}}";
var seed = 0;

// Create seed from date string and question ID
var combinedString = dateString + questionId;
for (var i = 0; i < combinedString.length; i++) {
    seed = ((seed << 5) - seed + combinedString.charCodeAt(i)) & 0xffffffff;
}

// Seeded random function
function seededRandom(seed) {
    var x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
}

// Seeded shuffle function
function seededShuffle(array, seed) {
    var currentIndex = array.length, temporaryValue, randomIndex;
    var currentSeed = seed;
    
    while (0 !== currentIndex) {
        currentSeed = (currentSeed * 9301 + 49297) % 233280;
        randomIndex = Math.floor(seededRandom(currentSeed) * currentIndex);
        currentIndex -= 1;
        
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    
    return array;
}

var shuffledAnswers = seededShuffle([...originalAnswers], seed);

// Generate HTML for shuffled answers
var buf = "";
for (var i = 0; i < shuffledAnswers.length; i++) {
    if (shuffledAnswers[i].text.trim()) { // Only show non-empty answers
        buf += '<div class="answer">' + shuffledAnswers[i].text + '</div>';
    }
}

document.getElementById("answers").innerHTML = buf;
</script>
            ''',
            'afmt': '''
<div class="question-container">
    <div class="meta-info">
        <div class="section">{{Section}}</div>
        <div class="subsection">{{Subsection}}</div>
    </div>
    
    <div class="question">
        <h3>{{Question}}</h3>
    </div>
    
    <div class="answers" id="answers-back">
        <!-- Answers will be dynamically generated by JavaScript -->
    </div>

    {{#Image}}
    <div class="image-container">
       {{Image}}
    </div>
    {{/Image}}
    
</div>

<script>
// Recreate the same shuffled order as front (using same seed approach)
var originalAnswers = [
    { label: 'A', text: "{{AnswerA}}" },
    { label: 'B', text: "{{AnswerB}}" },
    { label: 'C', text: "{{AnswerC}}" },
    { label: 'D', text: "{{AnswerD}}" }
];

var correctAnswers = "{{CorrectAnswers}}".split(", ");

// Generate the same date-based seed as used in the front template
var today = new Date();
var dateString = today.getFullYear() + "-" + (today.getMonth() + 1) + "-" + today.getDate();
var questionId = "{{QuestionID}}";
var seed = 0;

// Create seed from date string and question ID
var combinedString = dateString + questionId;
for (var i = 0; i < combinedString.length; i++) {
    seed = ((seed << 5) - seed + combinedString.charCodeAt(i)) & 0xffffffff;
}

// Seeded random function
function seededRandom(seed) {
    var x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
}

// Seeded shuffle function
function seededShuffle(array, seed) {
    var currentIndex = array.length, temporaryValue, randomIndex;
    var currentSeed = seed;
    
    while (0 !== currentIndex) {
        currentSeed = (currentSeed * 9301 + 49297) % 233280;
        randomIndex = Math.floor(seededRandom(currentSeed) * currentIndex);
        currentIndex -= 1;
        
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    
    return array;
}

var shuffledAnswers = seededShuffle([...originalAnswers], seed);

// Generate HTML for answers with correct highlighting
var buf = "";
for (var i = 0; i < shuffledAnswers.length; i++) {
    if (shuffledAnswers[i].text.trim()) {
        var answerText = shuffledAnswers[i].text;
        var isCorrect = correctAnswers.indexOf(shuffledAnswers[i].label) !== -1;
        
        if (isCorrect) {
            buf += '<div class="answer correct-answer">' + '<strong>' + answerText + '</strong></div>';
        } else {
            buf += '<div class="answer">' + answerText + '</div>';
        }
    }
}

document.getElementById("answers-back").innerHTML = buf;
</script>
            ''',
        },
    ],
    css='''
.card {
    font-family: arial;
    font-size: 14px;
    text-align: left;
    color: var(--text-fg);
    background-color: var(--canvas);
    padding: 15px;
    margin: 10px;
}

.question-container {
    max-width: 800px;
    margin: 0 auto;
}

.meta-info {
    background-color: var(--canvas-inset);
    color: var(--text-fg);
    padding: 10px;
    margin-bottom: 15px;
    border-radius: 5px;
    font-size: 12px;
    border: 1px solid var(--border);
}

.section {
    font-weight: bold;
    color: var(--accent-fg, #2c5aa0);
}

.subsection {
    color: var(--text-fg-faint, #666);
    margin-top: 5px;
}

.question {
    margin-bottom: 15px;
    color: var(--text-fg);
}

.question h3 {
    margin: 0;
    font-size: 16px;
    line-height: 1.4;
    color: var(--text-fg);
}

.image-container {
    text-align: center;
    margin: 15px 0;
    padding: 10px;
    background-color: var(--canvas-inset);
    border-radius: 5px;
    border: 1px solid var(--border);
}

.image-container img {
    max-width: 100%;
    height: auto;
    border-radius: 5px;
}

.answers {
    margin: 15px 0;
}

.answer {
    margin: 8px 0;
    padding: 8px;
    background-color: var(--canvas-inset);
    color: var(--text-fg);
    border-left: 3px solid var(--border);
    border-radius: 3px;
    line-height: 1.3;
}

.correct-answer {
    background-color: var(--flag-green, #e8f5e8);
    border-left: 3px solid var(--flag-green, #4CAF50);
    color: var(--text-fg);
}

.correct-answers {
    background-color: var(--flag-green, #e8f5e8);
    color: var(--text-fg);
    padding: 10px;
    border-radius: 5px;
    border-left: 4px solid var(--flag-green, #4CAF50);
    margin-top: 15px;
}

.correct-answers h4 {
    margin: 0;
    color: var(--flag-green, #2e7d2e);
}

/* Light theme fallbacks */
:root {
    --text-fg: #212121;
    --text-fg-faint: #666;
    --canvas: #ffffff;
    --canvas-inset: #f5f5f5;
    --border: #e0e0e0;
    --accent-fg: #2c5aa0;
    --flag-green: #4CAF50;
}

/* Dark theme support */
@media (prefers-color-scheme: dark) {
    :root {
        --text-fg: #e0e0e0;
        --text-fg-faint: #aaa;
        --canvas: #1e1e1e;
        --canvas-inset: #2d2d2d;
        --border: #444;
        --accent-fg: #5c9cfa;
        --flag-green: #66bb6a;
    }
}

/* Anki dark mode support */
.nightMode,
.night_mode {
    --text-fg: #e0e0e0;
    --text-fg-faint: #aaa;
    --canvas: #1e1e1e;
    --canvas-inset: #2d2d2d;
    --border: #444;
    --accent-fg: #5c9cfa;
    --flag-green: #66bb6a;
}

.nightMode .card,
.night_mode .card {
    background-color: var(--canvas);
    color: var(--text-fg);
}
    '''
)

def load_questions(json_path: str) -> List[Dict[str, Any]]:
    """Load questions from JSON file."""
    with open(json_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def find_image_file(abbildung_num: Optional[Union[str, int]], images_dir: str) -> Optional[str]:
    """Find the corresponding image file for an abbildung number."""
    if not abbildung_num:
        return None
    
    # Convert to integer if it's a string
    try:
        num = int(abbildung_num)
    except (ValueError, TypeError):
        print(f"Warning: Invalid abbildung number: {abbildung_num}")
        return None
    
    # Try the direct filename pattern
    image_path = os.path.join(images_dir, f"Abbildung_{num}.png")
    if os.path.exists(image_path):
        return image_path
    
    print(f"Warning: Image not found for Abbildung {abbildung_num}")
    return None

def create_sort_note_id(question_data: Dict[str, Any]) -> str:
    """Create a unique note ID based on question content."""
    content = f"{question_data['section_id']:03d}{question_data['subsection_id']:03d}{int(question_data['id']):03d}"
    return content

def create_note_id(question_data: Dict[str, Any]) -> int:
    """Create a unique note ID based on question content."""
    content = f"{question_data['section_id']:03d}{question_data['subsection_id']:03d}{int(question_data['id']):03d}"
    return int(hashlib.md5(content.encode('utf-8')).hexdigest()[:8], 16)

def create_anki_note(question_data: Dict[str, Any], images_dir: str, media_files: List[str]) -> genanki.Note:
    """Create an Anki note from question data."""
    # Get image if referenced
    image_filename = None
    
    if question_data.get('abbildung'):
        image_path = find_image_file(question_data['abbildung'], images_dir)
        if image_path:
            image_filename = os.path.basename(image_path)
            media_files.append(image_path)
    
    # Format correct answers
    correct_answers = ", ".join(question_data.get('correct', []))
    
    id = create_sort_note_id(question_data)
    tags = ['paragliding', 'dhv']
    def add_tags(tag_str: str):
        for tag in tag_str.split(', '):
            tag = tag.strip()
            tag = tag.replace(' ', '_')  # Replace spaces with underscores for tags
            if tag:
                tags.append(tag)
    
    add_tags(question_data.get('section', ''))
    add_tags(question_data.get('subsection', ''))
    
    # Create the note
    note = genanki.Note(
        model=PARAGLIDING_MODEL,
        fields=[
            id,
            question_data.get('section', ''),
            question_data.get('subsection', ''),
            question_data.get('question', ''),
            question_data.get('answers', {}).get('A', '').replace('"', '&quot;'),
            question_data.get('answers', {}).get('B', '').replace('"', '&quot;'),
            question_data.get('answers', {}).get('C', '').replace('"', '&quot;'),
            question_data.get('answers', {}).get('D', '').replace('"', '&quot;'),
            correct_answers,
            f'<img src="{image_filename}">' if image_filename else '',
        ],
        guid=create_note_id(question_data),
        tags=[tag for tag in tags if tag],  
    )
    
    return note

def generate_anki_deck(questions_json_paths: Union[str, List[str]], output_path: str, deckname: str= "DHV Lernmaterial Fragen", images_dir: str = "images") -> None:
    """Generate Anki deck from questions JSON files."""
    # Ensure questions_json_paths is a list
    if isinstance(questions_json_paths, str):
        questions_json_paths = [questions_json_paths]
    
    all_questions: List[Dict[str, Any]] = []
    
    # Load questions from all JSON files
    for json_path in questions_json_paths:
        try:
            print(f"Loading questions from {json_path}...")
            questions = load_questions(json_path)
            all_questions.extend(questions)
            print(f"Loaded {len(questions)} questions from {json_path}")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Error loading questions from {json_path}: {e}")
            continue
    
    print(f"Total questions loaded: {len(all_questions)}")
    
    # Create deck
    deck = genanki.Deck(
        2059420112,  # Unique deck ID
        deckname
    )
    
    media_files: List[str] = []
    notes_created = 0
    images_found = 0
    
    for question in all_questions:
        # Skip questions with empty questions or answers
        if not question.get('question') or not question.get('answers'):
            continue
            
        note = create_anki_note(question, images_dir, media_files)
        deck.add_note(note)
        notes_created += 1
        
        if question.get('abbildung'):
            image_path = find_image_file(question['abbildung'], images_dir)
            if image_path:
                images_found += 1
    
    print(f"Created {notes_created} notes")
    print(f"Found {images_found} images")
    print(f"Total media files: {len(set(media_files))}")
    
    # Create package with media files
    package = genanki.Package(deck)
    package.media_files = list(set(media_files))  # Remove duplicates
    
    # Write the deck
    print(f"Writing deck to {output_path}...")
    package.write_to_file(output_path)
    
    print(f"Successfully created Anki deck: {output_path}")
    print(f"Deck contains {notes_created} cards with {len(package.media_files)} media files")

def main():
    """Main function to generate the Anki deck."""
    current_dir = Path(__file__).parent
    questions_file = current_dir / "questions.json"
    additional_questions_file = current_dir / "extended_questions.json"
    images_dir = current_dir / "images"
    output_file = current_dir / "paragliding_questions.apkg"
    
    if not questions_file.exists():
        print(f"Error: Questions file not found: {questions_file}")
        return
    
    if not images_dir.exists():
        print(f"Warning: Images directory not found: {images_dir}")
        print("Continuing without images...")
        images_dir = None
    
    generate_anki_deck(
        [str(questions_file), str(additional_questions_file)],
        str(output_file),
        str(images_dir) if images_dir else "images"
    )

if __name__ == "__main__":
    main()